# TimeArea 开发指南

## 目录

1. [环境准备](#1-环境准备)
2. [项目初始化](#2-项目初始化)
3. [项目结构搭建](#3-项目结构搭建)
4. [类型定义](#4-类型定义)
5. [工具函数实现](#5-工具函数实现)
6. [API服务实现](#6-api服务实现)
7. [组件开发](#7-组件开发)
8. [状态管理](#8-状态管理)
9. [页面开发](#9-页面开发)
10. [样式和UI优化](#10-样式和ui优化)
11. [测试](#11-测试)
12. [构建和部署](#12-构建和部署)

---

## 1. 环境准备

### 1.1 安装Node.js

- 下载并安装 Node.js >= 16.0.0
- 验证安装：在终端运行 `node -v` 和 `npm -v`

### 1.2 选择代码编辑器

- 推荐使用 VS Code
- 安装必要的扩展：ESLint、Prettier、TypeScript

### 1.3 申请API密钥

**百度地图API密钥**：
1. 访问 https://lbsyun.baidu.com/
2. 注册/登录账号
3. 进入控制台，创建应用
4. 获取AK（Access Key）作为API密钥
5. 需要配置应用的IP白名单或域名白名单

**和风天气API密钥**：
1. 访问 https://dev.qweather.com/
2. 注册/登录账号
3. 创建应用，获取Key和Secret
4. 免费版支持每日1000次调用
5. 需要配置应用的域名白名单

---

## 2. 项目初始化

### 步骤1：创建Vite项目

在终端执行以下命令：

```bash
npm create vite@latest timearea -- --template react-ts
cd timearea
npm install
```

### 步骤2：安装依赖包

```bash
# UI组件库
npm install antd @ant-design/icons

# HTTP请求库
npm install axios

# 路由管理
npm install react-router-dom

# 状态管理
npm install zustand

# 日期处理
npm install dayjs

# 开发依赖
npm install -D @types/node
```

### 步骤3：配置环境变量

创建 `.env` 文件：

```env
VITE_WEATHER_API_KEY=your_qweather_api_key
VITE_WEATHER_API_SECRET=your_qweather_api_secret
VITE_MAP_API_KEY=your_baidu_map_ak
```

创建 `.env.example` 文件（示例，不包含真实密钥）：

```env
VITE_WEATHER_API_KEY=
VITE_WEATHER_API_SECRET=
VITE_MAP_API_KEY=
```

### 步骤4：配置Vite代理（可选，解决CORS问题）

编辑 `vite.config.ts`：

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api/weather': {
        target: 'https://devapi.qweather.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api\/weather/, '')
      },
      '/api/geocode': {
        target: 'https://api.map.baidu.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api\/geocode/, '')
      }
    }
  }
})
```

---

## 3. 项目结构搭建

### 步骤1：创建目录结构

在 `src` 目录下创建以下文件夹结构：

```
src/
├── components/        # 组件目录
│   ├── common/        # 通用组件
│   ├── route/        # 路线相关组件
│   └── weather/      # 天气相关组件
├── services/         # API服务
├── utils/            # 工具函数
│   ├── cache.ts      # 缓存工具
│   ├── storage.ts    # 存储工具
│   └── format.ts     # 格式化工具
├── store/            # 状态管理
├── types/            # 类型定义
├── hooks/            # 自定义Hooks
├── pages/            # 页面组件
└── styles/           # 样式文件
```

### 步骤2：创建基础文件

创建以下空文件（后续会填充内容）：

- `src/types/route.ts`
- `src/types/weather.ts`
- `src/utils/cache.ts`
- `src/utils/storage.ts`
- `src/utils/format.ts`
- `src/services/geocodeService.ts`
- `src/services/weatherService.ts`
- `src/store/routeStore.ts`
- `src/store/weatherStore.ts`

---

## 4. 类型定义

### 步骤1：定义路线相关类型

编辑 `src/types/route.ts`：

```typescript
// 经过点类型
export interface Waypoint {
  id: string;
  location: string;
  latitude?: number;
  longitude?: number;
  arrivalTime: string;
  order: number;
  weather?: WeatherInfo;
}

// 路线类型
export interface Route {
  id: string;
  name: string;
  waypoints: Waypoint[];
  createdAt: string;
  updatedAt: string;
}
```

### 步骤2：定义天气相关类型

编辑 `src/types/weather.ts`：

```typescript
// 天气信息类型
export interface WeatherInfo {
  location: string;
  date: string;
  time: string;
  temperature: number;
  humidity: number;
  windSpeed: number;
  precipitation: number;
  weatherCondition: string;
  icon: string;
  feelsLike?: number;
  pressure?: number;
  visibility?: number;
}

// 地理编码结果类型
export interface GeocodeResult {
  latitude: number;
  longitude: number;
  formattedAddress: string;
}

// 批量查询结果类型
export interface BatchQueryResult {
  location: string;
  geocode: GeocodeResult;
  arrivalTime: string;
  weather: WeatherInfo;
}
```

---

## 5. 工具函数实现

### 步骤1：实现缓存工具

编辑 `src/utils/cache.ts`：

```typescript
interface CacheItem<T> {
  data: T;
  expiresAt: number;
}

/**
 * 设置缓存
 * @param key 缓存键
 * @param data 缓存数据
 * @param ttl 过期时间（毫秒）
 */
export function setCache<T>(key: string, data: T, ttl: number): void {
  const item: CacheItem<T> = {
    data,
    expiresAt: Date.now() + ttl
  };
  localStorage.setItem(key, JSON.stringify(item));
}

/**
 * 获取缓存
 * @param key 缓存键
 * @returns 缓存数据，如果不存在或已过期返回null
 */
export function getCache<T>(key: string): T | null {
  const itemStr = localStorage.getItem(key);
  if (!itemStr) return null;

  try {
    const item: CacheItem<T> = JSON.parse(itemStr);
    
    // 检查是否过期
    if (Date.now() > item.expiresAt) {
      localStorage.removeItem(key);
      return null;
    }
    
    return item.data;
  } catch (error) {
    console.error('缓存解析失败:', error);
    localStorage.removeItem(key);
    return null;
  }
}

/**
 * 删除缓存
 * @param key 缓存键
 */
export function removeCache(key: string): void {
  localStorage.removeItem(key);
}

/**
 * 清空所有缓存
 */
export function clearCache(): void {
  const keys = Object.keys(localStorage);
  keys.forEach(key => {
    if (key.startsWith('weather:') || key.startsWith('geocode:')) {
      localStorage.removeItem(key);
    }
  });
}
```

### 步骤2：实现存储工具

编辑 `src/utils/storage.ts`：

```typescript
import { Route } from '../types/route';

const ROUTES_STORAGE_KEY = 'timearea_routes';

/**
 * 保存路线列表
 */
export function saveRoutes(routes: Route[]): void {
  localStorage.setItem(ROUTES_STORAGE_KEY, JSON.stringify(routes));
}

/**
 * 获取路线列表
 */
export function getRoutes(): Route[] {
  const routesStr = localStorage.getItem(ROUTES_STORAGE_KEY);
  if (!routesStr) return [];
  
  try {
    return JSON.parse(routesStr);
  } catch (error) {
    console.error('路线数据解析失败:', error);
    return [];
  }
}

/**
 * 添加路线
 */
export function addRoute(route: Route): void {
  const routes = getRoutes();
  routes.push(route);
  saveRoutes(routes);
}

/**
 * 更新路线
 */
export function updateRoute(routeId: string, route: Route): void {
  const routes = getRoutes();
  const index = routes.findIndex(r => r.id === routeId);
  if (index !== -1) {
    routes[index] = route;
    saveRoutes(routes);
  }
}

/**
 * 删除路线
 */
export function deleteRoute(routeId: string): void {
  const routes = getRoutes();
  const filtered = routes.filter(r => r.id !== routeId);
  saveRoutes(filtered);
}

/**
 * 导出路线数据为JSON
 */
export function exportRoutes(): string {
  const routes = getRoutes();
  return JSON.stringify(routes, null, 2);
}

/**
 * 导入路线数据
 */
export function importRoutes(jsonStr: string): Route[] {
  try {
    const routes = JSON.parse(jsonStr) as Route[];
    saveRoutes(routes);
    return routes;
  } catch (error) {
    console.error('导入路线数据失败:', error);
    throw new Error('无效的JSON格式');
  }
}
```

### 步骤3：实现格式化工具

编辑 `src/utils/format.ts`：

```typescript
import dayjs from 'dayjs';

/**
 * 格式化日期时间
 */
export function formatDateTime(dateTime: string): string {
  return dayjs(dateTime).format('YYYY-MM-DD HH:mm');
}

/**
 * 格式化日期
 */
export function formatDate(date: string): string {
  return dayjs(date).format('YYYY-MM-DD');
}

/**
 * 格式化时间
 */
export function formatTime(time: string): string {
  return dayjs(time, 'HH:mm').format('HH:mm');
}

/**
 * 生成唯一ID
 */
export function generateId(): string {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
```

---

## 6. API服务实现

### 步骤1：实现地理编码服务

编辑 `src/services/geocodeService.ts`：

```typescript
import axios from 'axios';
import { GeocodeResult } from '../types/weather';
import { getCache, setCache } from '../utils/cache';

const MAP_API_KEY = import.meta.env.VITE_MAP_API_KEY;
const MAP_API_URL = 'https://api.map.baidu.com/geocoding/v3/';

/**
 * 地理编码：地址转坐标
 */
export async function geocodeAddress(address: string): Promise<GeocodeResult> {
  // 检查缓存
  const cacheKey = `geocode:${address}`;
  const cached = getCache<GeocodeResult>(cacheKey);
  if (cached) {
    return cached;
  }

  try {
    const response = await axios.get(MAP_API_URL, {
      params: {
        address: address,
        ak: MAP_API_KEY,
        output: 'json'
      }
    });

    if (response.data.status === 0 && response.data.result) {
      const location = response.data.result.location;
      const result: GeocodeResult = {
        latitude: location.lat,
        longitude: location.lng,
        formattedAddress: response.data.result.formatted_address || address
      };

      // 永久缓存（地址基本不变）
      setCache(cacheKey, result, 365 * 24 * 60 * 60 * 1000);
      
      return result;
    }

    throw new Error(`地理编码失败：${response.data.message || '未找到结果'}`);
  } catch (error: any) {
    if (error.response) {
      throw new Error(`地理编码失败：${error.response.data?.message || 'API错误'}`);
    }
    throw new Error('地理编码失败：网络错误');
  }
}
```

### 步骤2：实现天气查询服务

编辑 `src/services/weatherService.ts`：

```typescript
import axios from 'axios';
import { WeatherInfo, BatchQueryResult } from '../types/weather';
import { GeocodeResult, geocodeAddress } from './geocodeService';
import { getCache, setCache } from '../utils/cache';
import dayjs from 'dayjs';

const WEATHER_API_KEY = import.meta.env.VITE_WEATHER_API_KEY;
const WEATHER_API_BASE_URL = 'https://devapi.qweather.com/v7';

/**
 * 查询天气
 */
export async function getWeather(
  latitude: number,
  longitude: number,
  date: string,
  time: string
): Promise<WeatherInfo> {
  // 检查缓存
  const cacheKey = `weather:${latitude}:${longitude}:${date}:${time}`;
  const cached = getCache<WeatherInfo>(cacheKey);
  if (cached) {
    return cached;
  }

  try {
    // 和风天气API：先通过经纬度获取locationId（使用v2版本的城市查询）
    const location = `${longitude},${latitude}`;
    const lookupResponse = await axios.get('https://devapi.qweather.com/v2/city/lookup', {
      params: {
        location: location,
        key: WEATHER_API_KEY
      }
    });

    if (lookupResponse.data.code !== '200' || !lookupResponse.data.location || lookupResponse.data.location.length === 0) {
      throw new Error(`天气查询失败：无法获取位置信息`);
    }

    const locationId = lookupResponse.data.location[0].id;
    const cityName = lookupResponse.data.location[0].name;

    // 查询7天天气预报
    const response = await axios.get(`${WEATHER_API_BASE_URL}/weather/7d`, {
      params: {
        location: locationId,
        key: WEATHER_API_KEY
      }
    });

    if (response.data.code !== '200') {
      throw new Error(`天气查询失败：${response.data.message || 'API错误'}`);
    }

    // 找到目标日期对应的天气数据
    const targetDate = dayjs(date);
    const dailyForecast = response.data.daily.find((item: any) => {
      const forecastDate = dayjs(item.fxDate);
      return forecastDate.isSame(targetDate, 'day');
    });

    if (!dailyForecast) {
      throw new Error('天气查询失败：未找到对应日期的预报数据');
    }

    const weatherData: WeatherInfo = {
      location: cityName,
      date: date,
      time: time,
      temperature: parseFloat(dailyForecast.tempMax),
      humidity: parseFloat(dailyForecast.humidity),
      windSpeed: parseFloat(dailyForecast.windSpeedDay),
      precipitation: parseFloat(dailyForecast.precip),
      weatherCondition: dailyForecast.textDay,
      icon: dailyForecast.iconDay,
      feelsLike: parseFloat(dailyForecast.tempMax),
      pressure: dailyForecast.pressure ? parseFloat(dailyForecast.pressure) : undefined,
      visibility: undefined
    };

    // 缓存2小时
    setCache(cacheKey, weatherData, 2 * 60 * 60 * 1000);

    return weatherData;
  } catch (error: any) {
    if (error.response) {
      throw new Error(`天气查询失败：${error.response.data?.message || 'API错误'}`);
    }
    throw new Error(`天气查询失败：${error.message || '网络错误'}`);
  }
}

/**
 * 批量查询天气
 */
export async function batchQueryWeather(
  waypoints: Array<{ location: string; arrivalTime: string }>
): Promise<BatchQueryResult[]> {
  const promises = waypoints.map(async (waypoint) => {
    const { location, arrivalTime } = waypoint;
    
    // 地理编码
    const geocode = await geocodeAddress(location);
    
    // 解析时间
    const dateTime = dayjs(arrivalTime);
    const date = dateTime.format('YYYY-MM-DD');
    const time = dateTime.format('HH:mm');
    
    // 查询天气
    const weather = await getWeather(
      geocode.latitude,
      geocode.longitude,
      date,
      time
    );
    
    return {
      location,
      geocode,
      arrivalTime,
      weather
    };
  });
  
  return Promise.all(promises);
}
```

---

## 7. 组件开发

### 步骤1：创建路线输入组件

创建 `src/components/route/RouteInput.tsx`：

```typescript
import React, { useState } from 'react';
import { Input, Button, DatePicker, TimePicker, Space, message } from 'antd';
import { PlusOutlined, DeleteOutlined } from '@ant-design/icons';
import dayjs, { Dayjs } from 'dayjs';

export interface WaypointInput {
  location: string;
  date: Dayjs | null;
  time: Dayjs | null;
}

interface RouteInputProps {
  onQuery: (waypoints: Array<{ location: string; arrivalTime: string }>) => void;
  loading?: boolean;
}

export const RouteInput: React.FC<RouteInputProps> = ({ onQuery, loading }) => {
  const [waypoints, setWaypoints] = useState<WaypointInput[]>([
    { location: '', date: null, time: null }
  ]);

  const addWaypoint = () => {
    setWaypoints([...waypoints, { location: '', date: null, time: null }]);
  };

  const removeWaypoint = (index: number) => {
    if (waypoints.length > 1) {
      setWaypoints(waypoints.filter((_, i) => i !== index));
    }
  };

  const updateWaypoint = (index: number, field: keyof WaypointInput, value: any) => {
    const updated = [...waypoints];
    updated[index][field] = value;
    setWaypoints(updated);
  };

  const handleQuery = () => {
    // 验证输入
    for (let i = 0; i < waypoints.length; i++) {
      const wp = waypoints[i];
      if (!wp.location.trim()) {
        message.error(`第${i + 1}个地点不能为空`);
        return;
      }
      if (!wp.date) {
        message.error(`第${i + 1}个地点的日期不能为空`);
        return;
      }
      if (!wp.time) {
        message.error(`第${i + 1}个地点的时间不能为空`);
        return;
      }
    }

    // 转换为API需要的格式
    const formattedWaypoints = waypoints.map(wp => ({
      location: wp.location.trim(),
      arrivalTime: wp.date!.hour(wp.time!.hour()).minute(wp.time!.minute()).toISOString()
    }));

    onQuery(formattedWaypoints);
  };

  return (
    <div className="route-input">
      {waypoints.map((waypoint, index) => (
        <Space key={index} style={{ marginBottom: 16, width: '100%' }} wrap>
          <Input
            placeholder="输入地点"
            value={waypoint.location}
            onChange={(e) => updateWaypoint(index, 'location', e.target.value)}
            style={{ width: 200 }}
          />
          <DatePicker
            placeholder="选择日期"
            value={waypoint.date}
            onChange={(date) => updateWaypoint(index, 'date', date)}
            format="YYYY-MM-DD"
          />
          <TimePicker
            placeholder="选择时间"
            value={waypoint.time}
            onChange={(time) => updateWaypoint(index, 'time', time)}
            format="HH:mm"
          />
          {waypoints.length > 1 && (
            <Button
              icon={<DeleteOutlined />}
              onClick={() => removeWaypoint(index)}
              danger
            />
          )}
        </Space>
      ))}
      <Space>
        <Button
          icon={<PlusOutlined />}
          onClick={addWaypoint}
          type="dashed"
        >
          添加经过点
        </Button>
        <Button
          type="primary"
          onClick={handleQuery}
          loading={loading}
        >
          查询天气
        </Button>
      </Space>
    </div>
  );
};
```

### 步骤2：创建天气展示组件

创建 `src/components/weather/WeatherDisplay.tsx`：

```typescript
import React from 'react';
import { Card, Row, Col, Tag, Spin } from 'antd';
import { BatchQueryResult } from '../../types/weather';
import { formatDateTime } from '../../utils/format';

interface WeatherDisplayProps {
  data: BatchQueryResult[];
  loading?: boolean;
}

export const WeatherDisplay: React.FC<WeatherDisplayProps> = ({ data, loading }) => {
  if (loading) {
    return (
      <div style={{ textAlign: 'center', padding: '50px' }}>
        <Spin size="large" />
      </div>
    );
  }

  if (data.length === 0) {
    return (
      <div style={{ textAlign: 'center', padding: '50px', color: '#999' }}>
        暂无天气数据
      </div>
    );
  }

  return (
    <Row gutter={[16, 16]}>
      {data.map((item, index) => (
        <Col xs={24} sm={12} md={8} lg={6} key={index}>
          <Card
            title={item.location}
            extra={<Tag color="blue">{formatDateTime(item.arrivalTime)}</Tag>}
            hoverable
          >
            <div className="weather-info">
              <div style={{ textAlign: 'center', marginBottom: 16 }}>
                <div style={{ fontSize: 48, fontWeight: 'bold', color: '#1890ff' }}>
                  {Math.round(item.weather.temperature)}°C
                </div>
              </div>
              <div style={{ textAlign: 'center', marginBottom: 16 }}>
                <img
                  src={`https://cdn.heweather.com/cond_icon/${item.weather.icon}.png`}
                  alt={item.weather.weatherCondition}
                  style={{ width: 64, height: 64 }}
                />
                <div>{item.weather.weatherCondition}</div>
              </div>
              <div style={{ fontSize: 14, color: '#666' }}>
                <div>湿度: {item.weather.humidity}%</div>
                <div>风速: {item.weather.windSpeed} m/s</div>
                <div>降水: {item.weather.precipitation}mm</div>
                {item.weather.feelsLike && (
                  <div>体感: {Math.round(item.weather.feelsLike)}°C</div>
                )}
              </div>
            </div>
          </Card>
        </Col>
      ))}
    </Row>
  );
};
```

---

## 8. 状态管理

### 步骤1：创建路线状态管理

编辑 `src/store/routeStore.ts`：

```typescript
import { create } from 'zustand';
import { Route } from '../types/route';
import { getRoutes, saveRoutes, addRoute as saveRoute, updateRoute as updateRouteStorage, deleteRoute as deleteRouteStorage } from '../utils/storage';
import { generateId } from '../utils/format';

interface RouteStore {
  routes: Route[];
  currentRoute: Route | null;
  loadRoutes: () => void;
  setCurrentRoute: (route: Route | null) => void;
  addRoute: (route: Omit<Route, 'id' | 'createdAt' | 'updatedAt'>) => void;
  updateRoute: (routeId: string, route: Partial<Route>) => void;
  deleteRoute: (routeId: string) => void;
}

export const useRouteStore = create<RouteStore>((set, get) => ({
  routes: [],
  currentRoute: null,

  loadRoutes: () => {
    const routes = getRoutes();
    set({ routes });
  },

  setCurrentRoute: (route) => {
    set({ currentRoute: route });
  },

  addRoute: (routeData) => {
    const now = new Date().toISOString();
    const newRoute: Route = {
      ...routeData,
      id: generateId(),
      createdAt: now,
      updatedAt: now
    };
    saveRoute(newRoute);
    set(state => ({ routes: [...state.routes, newRoute] }));
  },

  updateRoute: (routeId, routeData) => {
    const routes = get().routes;
    const route = routes.find(r => r.id === routeId);
    if (route) {
      const updated: Route = {
        ...route,
        ...routeData,
        updatedAt: new Date().toISOString()
      };
      updateRouteStorage(routeId, updated);
      set(state => ({
        routes: state.routes.map(r => r.id === routeId ? updated : r),
        currentRoute: state.currentRoute?.id === routeId ? updated : state.currentRoute
      }));
    }
  },

  deleteRoute: (routeId) => {
    deleteRouteStorage(routeId);
    set(state => ({
      routes: state.routes.filter(r => r.id !== routeId),
      currentRoute: state.currentRoute?.id === routeId ? null : state.currentRoute
    }));
  }
}));
```

### 步骤2：创建天气状态管理

编辑 `src/store/weatherStore.ts`：

```typescript
import { create } from 'zustand';
import { BatchQueryResult } from '../types/weather';
import { batchQueryWeather } from '../services/weatherService';

interface WeatherStore {
  weatherData: BatchQueryResult[];
  loading: boolean;
  error: string | null;
  queryWeather: (waypoints: Array<{ location: string; arrivalTime: string }>) => Promise<void>;
  clearWeather: () => void;
}

export const useWeatherStore = create<WeatherStore>((set) => ({
  weatherData: [],
  loading: false,
  error: null,

  queryWeather: async (waypoints) => {
    set({ loading: true, error: null });
    try {
      const results = await batchQueryWeather(waypoints);
      set({ weatherData: results, loading: false });
    } catch (error: any) {
      set({ 
        error: error.message || '查询失败', 
        loading: false,
        weatherData: []
      });
    }
  },

  clearWeather: () => {
    set({ weatherData: [], error: null });
  }
}));
```

---

## 9. 页面开发

### 步骤1：创建首页

编辑 `src/pages/Home.tsx`：

```typescript
import React, { useEffect } from 'react';
import { Layout, message } from 'antd';
import { RouteInput } from '../components/route/RouteInput';
import { WeatherDisplay } from '../components/weather/WeatherDisplay';
import { useWeatherStore } from '../store/weatherStore';

const { Content } = Layout;

export const Home: React.FC = () => {
  const { weatherData, loading, error, queryWeather, clearWeather } = useWeatherStore();

  useEffect(() => {
    if (error) {
      message.error(error);
    }
  }, [error]);

  const handleQuery = async (waypoints: Array<{ location: string; arrivalTime: string }>) => {
    clearWeather();
    await queryWeather(waypoints);
  };

  return (
    <Layout style={{ minHeight: '100vh' }}>
      <Content style={{ padding: '24px', maxWidth: '1200px', margin: '0 auto', width: '100%' }}>
        <div style={{ marginBottom: 24 }}>
          <h1>长途出行天气查询</h1>
          <p>输入经过地点和到达时间，查询沿途天气信息</p>
        </div>
        
        <div style={{ marginBottom: 24, padding: 24, background: '#fff', borderRadius: 8 }}>
          <RouteInput onQuery={handleQuery} loading={loading} />
        </div>

        {weatherData.length > 0 && (
          <div style={{ padding: 24, background: '#fff', borderRadius: 8 }}>
            <WeatherDisplay data={weatherData} loading={loading} />
          </div>
        )}
      </Content>
    </Layout>
  );
};
```

### 步骤2：配置路由

编辑 `src/App.tsx`：

```typescript
import React from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { ConfigProvider } from 'antd';
import zhCN from 'antd/locale/zh_CN';
import { Home } from './pages/Home';
import './App.css';

function App() {
  return (
    <ConfigProvider locale={zhCN}>
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<Home />} />
        </Routes>
      </BrowserRouter>
    </ConfigProvider>
  );
}

export default App;
```

### 步骤3：配置Ant Design样式

编辑 `src/main.tsx`：

```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import 'antd/dist/reset.css'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
```

---

## 10. 样式和UI优化

### 步骤1：添加全局样式

编辑 `src/index.css`：

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f0f2f5;
}

#root {
  min-height: 100vh;
}

.weather-info {
  text-align: center;
}
```

### 步骤2：添加响应式样式

创建 `src/styles/responsive.css`：

```css
@media (max-width: 768px) {
  .route-input {
    padding: 16px;
  }
  
  .route-input .ant-space {
    width: 100%;
  }
  
  .route-input .ant-input,
  .route-input .ant-picker {
    width: 100% !important;
    margin-bottom: 8px;
  }
}
```

---

## 11. 测试

### 步骤1：安装测试依赖

```bash
npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

### 步骤2：配置Vitest

创建 `vitest.config.ts`：

```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: './src/test/setup.ts'
  }
});
```

### 步骤3：创建测试工具函数

创建 `src/test/setup.ts`：

```typescript
import '@testing-library/jest-dom';
```

### 步骤4：编写组件测试示例

创建 `src/components/route/RouteInput.test.tsx`：

```typescript
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { RouteInput } from './RouteInput';

describe('RouteInput', () => {
  it('应该渲染输入框', () => {
    render(<RouteInput onQuery={() => {}} />);
    expect(screen.getByPlaceholderText('输入地点')).toBeInTheDocument();
  });
});
```

---

## 12. 构建和部署

### 步骤1：构建项目

```bash
npm run build
```

构建产物在 `dist` 目录。

### 步骤2：本地预览

```bash
npm run preview
```

### 步骤3：部署到Vercel

1. 安装Vercel CLI：`npm i -g vercel`
2. 在项目根目录运行：`vercel`
3. 按照提示配置环境变量

### 步骤4：部署到Netlify

1. 在Netlify网站创建新项目
2. 连接GitHub仓库
3. 构建命令：`npm run build`
4. 发布目录：`dist`
5. 在环境变量中配置API密钥

---

## 开发注意事项

1. **API密钥安全**：不要将 `.env` 文件提交到Git仓库
2. **CORS问题**：如果遇到跨域问题，使用Vite代理或配置API服务的CORS
3. **错误处理**：所有API调用都要有错误处理
4. **用户体验**：添加加载状态和错误提示
5. **数据验证**：验证用户输入，防止无效数据
6. **缓存管理**：定期清理过期缓存，避免localStorage溢出

---

## 下一步优化

1. 添加路线保存功能
2. 添加地图可视化
3. 添加天气图表展示
4. 添加数据导出/导入功能
5. 添加PWA支持
6. 添加国际化支持
