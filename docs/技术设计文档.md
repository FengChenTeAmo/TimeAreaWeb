# TimeArea 技术设计文档

## 1. 系统架构设计

### 1.1 整体架构

```
┌─────────────┐
│   用户界面   │
│  (Frontend) │
└──────┬──────┘
       │ HTTP/HTTPS
       │
┌──────▼──────┐
│  第三方API  │
│ (天气/地图) │
└─────────────┘
```

### 1.2 技术选型说明

#### 前端技术选型

**推荐方案：React + TypeScript + Vite**

- **React**: 组件化开发，生态丰富
- **TypeScript**: 类型安全，提高代码质量
- **Vite**: 快速构建，开发体验好
- **Ant Design**: 企业级UI组件库，开箱即用
- **React Router**: 路由管理
- **Zustand**: 轻量级状态管理
- **Axios**: HTTP请求库

## 2. 核心功能实现

### 2.1 地点输入和地理编码

**功能说明**：
- 用户在前端输入地点名称（如"北京市朝阳区"）
- 前端直接调用百度地图API的地理编码接口，将地址转换为经纬度坐标
- API密钥通过环境变量配置（Vite使用import.meta.env），前端直接使用
- 返回结果包含纬度、经度和格式化后的地址信息
- 地理编码结果会缓存到localStorage，避免重复查询相同地址
- 如果API调用失败，显示友好的错误提示，允许用户重试

### 2.2 天气查询服务

**功能说明**：
- 前端使用经纬度坐标和日期时间，直接调用和风天气API查询天气预报
- 查询前先检查localStorage缓存，如果存在且未过期则直接使用缓存数据
- API返回的是未来几天的天气预报列表，需要找到最接近目标时间的预报数据
- 解析返回的天气数据，提取温度、湿度、风速、降水概率、天气状况和图标等信息
- 将查询结果保存到localStorage，设置2小时过期时间，减少API调用次数
- 如果API调用失败，显示错误提示并允许用户重试

### 2.3 批量天气查询

**功能说明**：
- 用户输入多个经过地点和对应的到达时间
- 前端对每个地点依次进行地理编码，将地址转换为坐标（优先使用缓存）
- 解析每个地点的到达时间，提取日期和时间部分
- 使用Promise.all并发查询所有地点的天气信息，提高查询效率
- 返回包含地点、坐标、到达时间和天气信息的完整数据
- 如果某个地点查询失败，不影响其他地点的查询，但会显示错误提示
- 所有查询结果都在浏览器端处理，不经过任何服务器

### 2.4 数据存储和管理

**功能说明**：
- 使用浏览器localStorage存储用户创建的路线信息
- 路线数据包括：路线名称、经过点列表、创建时间等
- 使用localStorage存储天气查询历史记录
- 缓存数据设置过期时间，自动清理过期缓存
- 所有数据都在用户浏览器本地存储，不会上传到服务器
- 支持导出路线数据为JSON文件
- 支持导入JSON文件恢复路线数据

## 3. 前端组件设计

### 3.1 路线输入组件

**功能说明**：
- 提供输入框供用户输入地点名称
- 提供日期选择器选择到达日期
- 提供时间选择器选择到达时间
- 支持动态添加多个经过点
- 支持删除经过点（至少保留一个）
- 实时更新经过点信息到组件状态
- 提供查询按钮，触发批量天气查询

### 3.2 天气展示组件

**功能说明**：
- 以卡片形式展示每个地点的天气信息
- 卡片标题显示地点名称，右上角显示到达时间
- 主要显示温度信息，使用大字体突出显示
- 显示天气图标和天气状况描述
- 显示详细信息：湿度、风速、降水概率
- 使用响应式布局，适配不同屏幕尺寸
- 支持列表视图和网格视图切换
- 所有数据渲染都在浏览器端完成

### 3.3 路线管理组件

**功能说明**：
- 显示用户保存的路线列表（从localStorage读取）
- 支持创建新路线、编辑已有路线、删除路线
- 路线数据保存在浏览器localStorage中
- 支持路线重命名和排序
- 点击路线可查看详情和天气信息
- 所有操作都在浏览器端完成，无需服务器支持

## 4. 性能优化

### 4.1 缓存策略

1. **天气数据缓存**
   - 使用localStorage缓存天气数据，过期时间2小时
   - 缓存键格式：`weather:纬度:经度:日期:时间`
   - 查询前先检查缓存，存在且未过期则直接使用
   - 相同地点和时间段复用缓存，减少API调用

2. **地理编码缓存**
   - 地址到坐标的映射永久缓存到localStorage（地址基本不变）
   - 缓存键格式：`geocode:地址名称`
   - 首次查询后缓存结果，后续相同地址直接使用缓存
   - 大幅减少API调用次数，提升响应速度

3. **路线数据存储**
   - 用户创建的路线保存在localStorage中
   - 存储键：`timearea_routes`，存储格式为JSON数组
   - 支持浏览器本地持久化，关闭浏览器后数据仍然保留
   - 注意localStorage有大小限制（通常5-10MB），需要定期清理旧数据

### 4.2 前端优化

1. **懒加载**
   - 路由懒加载
   - 组件按需加载

2. **防抖节流**
   - 搜索输入防抖
   - 滚动事件节流

3. **虚拟列表**
   - 大量数据使用虚拟滚动

## 5. 安全考虑

1. **API密钥保护**
   - 使用环境变量管理API密钥
   - 注意：前端API密钥会暴露在代码中，需要在第三方服务配置域名白名单

2. **输入验证**
   - 验证用户输入
   - 防止XSS攻击
   - 对用户输入进行转义

3. **CORS处理**
   - 前端直接调用第三方API可能遇到跨域问题
   - 如果API支持CORS，浏览器会自动处理
   - 如果API不支持CORS，需要在开发环境配置Vite代理
   - 生产环境可能需要使用支持CORS的API或配置反向代理
   - 某些API可能支持JSONP方式调用，可以作为备选方案

4. **HTTPS**
   - 生产环境使用HTTPS
   - 保护数据传输安全

## 6. 测试策略

### 6.1 单元测试

**测试内容**：
- 测试天气查询服务函数，验证能正确调用API并返回天气数据
- 测试地理编码服务函数，验证能正确转换地址为坐标
- 测试缓存功能，验证能正确存储和读取缓存数据
- 测试数据格式化函数，验证能正确处理时间、日期等数据

### 6.2 组件测试

**测试内容**：
- 测试路线输入组件，验证输入框、日期选择器等元素能正常渲染
- 测试天气展示组件，验证能正确显示天气信息
- 测试用户交互，验证添加、删除经过点等功能正常工作
- 测试错误处理，验证API调用失败时能正确显示错误信息

## 7. 数据流说明

### 7.1 用户输入流程

1. 用户在浏览器中输入经过地点和到达时间
2. 前端组件收集用户输入，存储在组件状态中
3. 用户点击查询按钮，触发批量天气查询

### 7.2 数据查询流程

1. 前端检查localStorage缓存，如果存在则直接使用
2. 如果缓存不存在或已过期，调用第三方API（百度地图、和风天气）
3. API返回数据后，前端解析并格式化数据
4. 将查询结果保存到localStorage缓存
5. 更新组件状态，渲染天气信息到页面

### 7.3 数据存储流程

1. 用户创建的路线数据保存在localStorage中
2. 每次查询的天气数据也会缓存到localStorage
3. 所有数据都在浏览器本地，不会发送到任何服务器
4. 用户可以通过导出功能将数据保存为JSON文件
5. 用户可以通过导入功能从JSON文件恢复数据

## 8. 部署方案

### 8.1 静态托管部署

项目构建后生成纯静态文件（HTML、CSS、JavaScript），可以部署到：

- **Vercel**: 自动部署，支持环境变量配置
- **Netlify**: 静态站点托管，支持环境变量
- **GitHub Pages**: 免费静态托管，适合开源项目
- **传统服务器**: Nginx等静态文件服务器，只需配置静态文件服务

### 8.2 构建说明

使用构建命令生成生产环境的静态文件，构建产物位于 `dist` 目录。将 `dist` 目录的内容部署到静态托管服务即可。

**重要说明**：
- 这是一个纯前端应用，不需要服务器、数据库或后端服务
- 所有数据都在用户浏览器本地处理
- 只需要一个能提供静态文件访问的Web服务器即可
- API密钥需要在第三方服务（百度地图、和风天气）配置域名白名单
